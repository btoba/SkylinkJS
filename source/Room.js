/**
 * Handles the room connection.
 * @class Room
 * @for Skylink
 * @since 0.6.0
 */
function Room(name, listener) {
  'use strict';

  // Reference of instance
  var com = this;

  /**
   * The room id.
   * @attribute name
   * @type String
   * @private
   * @for Room
   * @since 0.6.0
   */
  com.id = fn.generateUID();

  /**
   * The room name.
   * @attribute name
   * @type String
   * @private
   * @for Room
   * @since 0.6.0
   */
  com.name = name;


  /**
   * The request path to the api server.
   * @attribute path
   * @type String
   * @private
   * @for Room
   * @since 0.6.0
   */
  com.apiPath = null;

  /**
   * The room configuration settings received from server.
   * @attribute apiConfig
   * @param {String} id The room id.
   * @param {String} token The room token.
   * @param {String} key The room key.
   * @param {String} startDateTime The room start date timestamp (ISO format).
   * @param {Integer} duration The room duration.
   * @type JSON
   * @private
   * @for Room
   * @since 0.6.0
   */
  com.apiConfig = {};

  /**
   * The room api owner.
   * @attribute owner
   * @type String
   * @private
   * @for Room
   * @since 0.6.0
   */
  com.owner = null;

  /**
   * The user set settings for the room.
   * @attribute credentials
   * @param {Integer} duration The room duration set by user.
   * @param {String} hash The hashed secret generated by user.
   * @param {String} startDateTime The room start date timestamp (ISO format) set by user.
   * @type JSON
   * @private
   * @for Room
   * @since 0.6.0
   */
  com.credentials = globals.credentials;

  /**
   * The user self connection information.
   * @attribute self
   * @param {String} id The user id for this room.
   * @param {String} token The user token for this room.
   * @param {String} timeStamp The date timestamp (ISO format) for this room.
   * @param {String} data The user data.
   * @param {JSON} data The streams.
   * @param {Stream} <streamId> The stream connected to room.
   * @type JSON
   * @private
   * @for Room
   * @since 0.6.0
   */
  com.self = {};

  /**
   * The list of users connected to room.
   * @attribute users
   * @param {String} <userId> The user connected to room.
   * @param {Peer} <userId>.<peerId The peer connected.
   * @type JSON
   * @private
   * @for Room
   * @since 0.6.0
   */
  com.users = {};

  /**
   * The list of components connected to room.
   * - E.g. MCU, Recording
   * @attribute user
   * @param {User} [n=*] The user connected to room.
   * @type JSON
   * @private
   * @for Room
   * @since 0.6.0
   */
  com.components = {};

  /**
   * The room duration.
   * @attribute startDateTime
   * @type Socket
   * @required
   * @private
   * @for Room
   * @since 0.6.0
   */
  com.socket = null;
  
  /**
   * The room readyState.
   * @attribute readyState
   * @type Integer
   * @required
   * @private
   * @for Room
   * @since 0.6.0
   */
  com.readyState = 0;
  
  /**
   * The room locked state.
   * @attribute locked
   * @type Boolean
   * @required
   * @private
   * @for Room
   * @since 0.6.0
   */
  com.locked = false;

  /**
   * Starts the connection to the room.
   * @method join
   * @trigger peerJoined, mediaAccessRequired
   * @for Room
   * @since 0.6.0
   */
  com.join = function (stream) {
    // Get user info for socket messaging
    var userInfo;

    if (stream) {
      com.self.streams[stream.id] = stream;
      userInfo = com.getUserInfo();
      userInfo.settings = userInfo.settings[stream.id];
    
    } else {
      userInfo = com.getUserInfo();
      userInfo.settings = {};
    }
    // Remove reference
    delete userInfo.agent;

    // User is in the Room
    com.socket.when('inRoom', function (data) {
      com.self.userId = data.sid;
      
      com.socket.send({
        type: 'enter',
        mid: com.self.userId,
        rid: com.apiConfig.id,
        prid: 'main',
        agent: window.webrtcDetectedBrowser,
        version: window.webrtcDetectedVersion,
        webRTCType: window.webrtcDetectedType,
        userInfo: userInfo
      });
      
      com.onJoin();
    });
    
    // Peer has joined the Room
    com.socket.when('enter', function (data) {
      com.addUserPeer(data, stream);
      
      com.socket.send({
        type: 'welcome',
        mid: com.self.userId,
        rid: com.apiConfig.id,
        prid: data.prid,
        agent: window.webrtcDetectedBrowser,
        version: window.webrtcDetectedVersion,
        webRTCType: window.webrtcDetectedType,
        userInfo: com.getUserInfo(),
        target: data.mid,
        weight: com.users[data.mid][data.prid].weight
      });
    });
    
    // Peer handshaking
    com.socket.when('welcome', function (data) {
      if (data.prid === 'main') {
        com.addUserPeer(data, stream);
      } else {
        com.addUserPeer(data);
      }
    });

    com.socket.connect();
    console.log('->joined');
  };

  /**
   * Stops the connection to the room.
   * @method leave
   * @trigger peerJoined, mediaAccessRequired
   * @for Room
   * @since 0.6.0
   */
  com.leave = function () {
    com.socket.disconnect();
  };
  
  /**
   * Locks the Room.
   * @method lock
   * @trigger peerJoined, mediaAccessRequired
   * @for Room
   * @since 0.6.0
   */
  com.lock = function (options) {
    //com.socket.connect();
  };

  /**
   * Unlocks the Room.
   * @method unlock
   * @trigger peerJoined, mediaAccessRequired
   * @for Room
   * @since 0.6.0
   */
  com.unlock = function () {
    //com.socket.disconnect();
  };
 
  /**
   * Handles the event when room succesfully disconnects.
   * @method onLeave
   * @for Room
   * @since 0.6.0
   */
  com.onLeave = function () {
    listener('room:disconnect', {
      name: com.name,
      userId: com.self.id
    });
  };

  /**
   * Handles the event when room succesfully connects.
   * @method onJoin
   * @for Room
   * @since 0.6.0
   */
  com.onJoin = function () {
    listener('room:connect', {
      name: com.name,
      userId: com.self.id
    });
  };

  /**
   * Locks the Room.
   * @method lock
   * @trigger peerJoined, mediaAccessRequired
   * @for Room
   * @since 0.6.0
   */
  com.addUserPeer = function (data, stream) {
    console.log('->addUserPeer');
    var doOffer = data.type === 'welcome';

    com.users[data.mid] = com.users[data.mid] || {};

    // Received duplicate
    if (fn.isSafe(function () { return !!com.users[data.mid][data.prid]; })) {
      if (data.type === 'welcome') {
        if (com.users[data.mid][data.prid].weight < data.weight) {
          doOffer = false;
        }
      }
    // Create since peer doesn't exists
    } else {
      var peer = new Peer({
        id: data.prid,
        userId: data.mid,
        data: data.userInfo.userData,
        agent: data.agent,
        dataChannel: globals.dataChannel,
        streamingConfig: {
          audio: fn.isSafe(function () { 
            data.userInfo.settings.audio 
          }),
          video: fn.isSafe(function () { 
            data.userInfo.settings.video 
          }),
          status: fn.isSafe(function () { 
            data.userInfo.settings.mediaStatus 
          })
        }
      }, function (event, edata) {
        listener(event, edata);
  
        if (event === 'peer:localdescription:success') {
          console.info(edata);
          
          com.socket.send({
            type: edata.sdp.type,
            sdp: edata.sdp,
            mid: com.self.userId,
            prid: data.prid,
            target: data.mid,
            rid: com.apiConfig.id
          });
        }
        
        if (event === 'peer:icecandidate') {
          com.socket.send({
            type: 'candidate',
            label: edata.candidate.sdpMLineIndex,
            id: edata.candidate.sdpMid,
            candidate: edata.candidate.candidate,
            mid: com.self.userId,
            prid: data.prid,
            target: data.mid,
            rid: com.apiConfig.id
          });
        }
      });

      com.users[data.mid][data.prid] = peer;

      peer.connect(stream);
    }
    
    if (doOffer) {
      peer.createOffer();
      console.log('->offer created');
    }
  };

  /**
   * Updates the user data.
   * @method updateUser
   * @for Room
   * @since 0.6.0
   */
  com.updateUser = function (data) {
    self.data = data;
  };
  
  /**
   * Sends another stream
   * @method updateUser
   * @for Room
   * @since 0.6.0
   */
  com.sendNewStream = function (stream, userId) {
    // Get user info for socket messaging
    var userInfo;
    var prid = fn.generateUID();

    if (stream) {
      com.self.streams[stream.id] = stream;
      userInfo = com.users[userId]['main'].getInfo();
      userInfo.settings = userInfo.settings[stream.id];
    
    } else {
      userInfo = com.users[userId]['main'].getInfo();
      userInfo.settings = {};
    }
    // Remove reference

    com.addUserPeer({
      type: 'enter',
      mid: userId,
      rid: com.apiConfig.id,
      prid: prid,
      agent: userInfo.agent.name,
      version: userInfo.agent.version,
      webRTCType: userInfo.agent.webRTCType,
      userInfo: userInfo
    }, stream);

    room.socket.send({
      type: 'welcome',
      mid: com.self.userId,
      rid: com.apiConfig.id,
      prid: prid,
      agent: window.webrtcDetectedBrowser,
      version: window.webrtcDetectedVersion,
      webRTCType: window.webrtcDetectedType,
      userInfo: com.getUserInfo(),
      target: userId,
      weight: com.users[userId][prid].weight
    });
  };

  /**
   * Gets the user info.
   * @method updateUser
   * @for Room
   * @since 0.6.0
   */
  com.getUserInfo = function () {
    return {
      userData: com.self.data,
      settings: (function () {
        var streaming = {};
  
        com.self.streams.forEach(function (value, key) {
          streaming[key] = {
            audio: value.config.audio,
            video: value.config.video,
            mediaStatus: value.config.status,
            bandwidth: {}
          }
        });
        
        return streaming;
      })(),
      agent: {
        name: window.webrtcDetectedBrowser,
        version: window.webrtcDetectedVersion,
        webRTCType: window.webrtcDetectedType
      }
    };
  };

  /**
   * Sets the user info.
   * @method updateUser
   * @for Room
   * @since 0.6.0
   */
  com.setUserInfo = function (data) {
    com.self.data = data;

    com.socket.send({
      type: 'updateUserEvent',
      mid: com.self.userId,
      rid: com.apiConfig.id,
      userData: com.self.data
    });
  };

  // Start loading the room information
  var path = '/api/' + globals.apiKey + '/' + com.name;

  // Set credentials if there is
  if (com.credentials !== null) {
    path += com.credentials.startDateTime + '/' +
      com.credentials.duration + '?&cred=' + com.credentials.hash;
  }

  // Check if there is a other query parameters or not
  if (globals.region) {
    path += (path.indexOf('?&') > -1 ? '&' : '?&') + 'rg=' + globals.region;
  }

  // Start connection
  Request.load(path, function (status, content) {
    // Store the path information
    com.apiPath = path;

    // Room configuration settings from server
    com.apiConfig = {
      key: content.cid,
      id: content.room_key,
      token: content.roomCred,
      startDateTime: content.start,
      duration: content.len
    };
    
    com.owner = content.apiOwner;

    // User configuration settings from server
    com.self = {
      userId: null,
      connectId: content.username,
      token: content.userCred,
      timeStamp: content.timeStamp,
      data: globals.userData,
      constraints: JSON.parse(content.pc_constraints),
      streams: {}
    };

    // Signalling information
    com.socket = new Socket({
      server: content.ipSigserver,
      httpPortList: content.httpPortList,
      httpsPortList: content.httpsPortList

    }, function (event, data) {
      listener(event, data);

      if (event === 'socket:disconnect') {
        //com.self.disconnect();
        com.onLeave();
      }

      if (event === 'socket:connect') {
        com.socket.send({
          type: 'joinRoom',
          uid: com.self.connectId,
          cid: com.apiConfig.key,
          rid: com.apiConfig.id,
          userCred: com.self.token,
          timeStamp: com.self.timeStamp,
          apiOwner: com.owner,
          roomCred: com.apiConfig.token,
          start: com.apiConfig.startDateTime,
          len: com.apiConfig.duration
        });
      }
    });
    
    // Peer handshaking
    com.socket.when('offer', function (data) {
      var peer = com.users[data.mid][data.prid];
      
      peer.setRemoteDescription(data.sdp);
      
      peer.createAnswer();
    });
  
    // Peer handshaking
    com.socket.when('answer', function (data) {
      var peer = com.users[data.mid][data.prid];
      
      peer.setRemoteDescription(data.sdp);
    });
    
    // Peer connecting
    com.socket.when('candidate', function (data) {
      var peer = com.users[data.mid][data.prid];
      
      var candidate = new window.RTCIceCandidate({
        sdpMLineIndex: data.label,
        candidate: data.candidate,
        sdpMid: data.id
      });
    
      console.info('candidate', candidate);
      peer.addIceCandidate(candidate);
    });
    
    // Socket messaging events
    // Peer information updated
    com.socket.when('updateUserEvent', function (data) {
      var peer = com.users[data.mid][data.prid];
      
      peer.onUpdate(peer.getInfo());
    });
    
    // Peer stream audio muted
    com.socket.when('muteAudioEvent', function (data) {
      var peer = com.users[data.mid][data.prid];
      
      // Triggers stream events
      peer.stream.status.audioMuted = data.muted;
      peer.stream.muteAudio();
      
      // Triggers peer update event
      peer.onUpdate(peer.getInfo());
    });
    
    // Peer stream video muted
    com.socket.when('muteVideoEvent', function (data) {
      var peer = com.users[data.mid][data.prid];
      
      // Triggers stream events
      peer.stream.status.videoMuted = data.muted;
      peer.stream.muteVideo();
      
      // Triggers peer update event
      peer.onUpdate(peer.getInfo());
    });

    // Room lock event
    com.socket.when('roomLockEvent', function (data) {
      com.locked = data.lock;
      
      if (com.locked) {
        com.onLock(data.mid);
      
      } else {
        com.onUnlock(data.mid);
      }
    });
    
    // Redirect event
    com.socket.when('redirect', function (data) {
      
    });
    
    // Redirect event
    com.socket.when('restart', function (data) {
      peer.restart(data);
    });
    
    // Peer connecting
    com.socket.when('bye', function (data) {
      com.users[data.mid].forEach(function (value, key) {
        value.disconnect();
      });
      //delete com.users[data.mid];
    }); 
    
    listener('room:start', {
      id: com.id,
      name: com.name
    });
  
  }, function (status, error) {
    com.readyState = -1;

    listener('room:error', {
      id: com.id,
      name: com.name,
      error: error
    });
  });
}